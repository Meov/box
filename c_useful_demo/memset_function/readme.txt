void *memset(void *s, int c, size_t n)
----fill memory with a constant byte

memset填充目标内存内容是按字节填充的，可用来填充字符数组、初始化各种数组等。

注意点：
	由于其是按照字节进行填充，针对几种存放几种不同类型的数组，在填充时可能会有不同的结果
	(1): char类型数组
		
		char a[10];
		memset(a,0,sizeof(a));
		
		表示将字符数组a全部用0进行填充，按字节填充，此时a[0],a[2]...a[9]均为0
		当填充的常数项Int值为1时,此时a[0],a[2]...a[9]均为1
	(2): int类型数组
		int a[10];
		memset(a,0,sizeof(a));
		由于int类型数组每个元素占据4个字节，因此在填充时，每个元素填充情况如下：
		0x00000000， 即此时 a[0] = 0x00000000,a[1]=a[2]...a[9] = 0x00000000 
		memset(a,1,sizeof(a));
		0x01010101, 注意此时： a[0] = 0x01010101,a[1]=a[2]...a[9] = 0x01010101
		每个元素不为理想中的1，在非字符型数组初始化时使用该函数一定要注意！

		观察在填充 -1 时的情况，因为-1的补码时注意到:
		-1的原码是1000 0001   它的反码就是 1111 1110  它的补码就是 1111 1111 = 0xff 当将其按字节写入时,每个元素填充如下：
		a[0] = 0xffffffff 而 0xffffffff 的值就是 -1

	负数表示：

	原码：10进制转换成2进制是原码，只不过正数的原码是本身符号位为0，负数的原码符号位为1（以下篇幅均以单字节为例：10进制1的原码是0000 0001，10进制-1的原码是1000 0001）。

	反码： 正数的反码是本身，负数的反码是负数的原码0变为1,1变为0   （-1的原码是1000 0001   它的反码就是 1111 1110，）。（注意负数求反码时候的符号位不参与变换）。

	补码： 正数的补码是本身，负数的补码就是负数的反码加一 （-1的原码是1000 0001   它的反码就是 1111 1110  它的补码就是 1111 1111）。

总结：
	填充数组：
		填充的值应该尽可能为 0 或者 -1， 其它值在非char型的数组时，会有一定的风险。

	填充字符数组：
		不存在此问题，可按需求进行填充。	
		
	void *memset(void *s, int c, size_t n){
		int i = 0;
		char *byte = (char*)s;
		for(i = 0; i < c; i++){
			*byte++ = (char)c;
		}
	}
